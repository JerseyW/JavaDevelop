package Algorithm.Sort;

/**
 * @author: Jerssy
 * @create: 2021-03-11 13:07
 * @version: V1.0
 * @slogan: 业精于勤, 荒于嬉;行成于思,毁于随。
 * @description:
 *
 *  时间频度 ：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。
 *
 *
 *  时间复杂度：一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。
 *  记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。
 *
 *
 * 随着执行次数的增加：其常数项，高次项系数，低次项
 *
 * 计算时间复杂度的方法：
 *
 *
 * 用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+6  => T(n)=n²+7n+1
 *
 * 修改后的运行次数函数中，只保留最高阶项  T(n)=n²+7n+1 => T(n) = n²
 *
 * 去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)
 *
 *
 * 常见的时间复杂度:
 *
 * 常数阶O(1)
 *
 * 对数阶O(log2n)
 *
 * 线性阶O(n)
 *
 * 线性对数阶O(nlog2n)
 *
 * 平方阶O(n^2)
 *
 * 立方阶O(n^3)
 *
 * k次方阶O(n^k)
 *
 * 指数阶O(2^n)
 *
 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n^2)＜Ο(n^3)＜ Ο(n^k) ＜Ο(2^n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低

指数阶时间复杂度：
    fun(n) {
       if(n <= 1) {
         return 2;
       } else {
            return fun(n - 1) + fun(n - 2)
        }
    }

平均时间复杂度和最坏时间复杂度

平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。

最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。
这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。




空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。
有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，
例如快速排序和归并排序算法 基数排序就属于这种情况


 */
public class SortTest {

    public static void main(String[] args) {
        System.out.println(fun(4));
    }

    public  static int fun(int n) {
        if(n <= 1) {
            return 2;
        } else {
            int fun = fun(n - 1);
            int fun1 = fun(n - 2);
            return fun + fun1;
        }
    }
}
