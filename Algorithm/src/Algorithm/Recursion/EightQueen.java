package Algorithm.Recursion;

/**
 * @author Jerssy
 * @version V1.0
 * @Description 八皇后问题
 * @create 2021-02-27 9:56
 *
 * 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于
 * 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即： 任意两个皇后都不能处于同一行 、
 * 同一列或同一斜线上，问有多少种摆法(92)。
 *
 * 根据组合数学：C64 取8，一共有4.426×10的9次方种方案
 *
 * 不难发现，每一行只能放一个皇后，所以8！=40320种方案
 *
 * 然后在40320种方案中，挑选符合题意的方案！
 *
 *
 * 根据条件我们可知每行每列最多都只能有一个皇后，这样可以在一定程度上缩减问题的规模。在第一行的某一列选择放置一个皇后，共有8种不同的选择，而第二行只能选择剩下的7列，也就是7种选择，剩下每一行的选择都会递减1，
 * 那么总共可供选择的方案有8的阶乘种，已经是一种远优于暴力解法的解法，
 * 但是这个阶乘的时间复杂度恐怕也难以令人接受，还有更优的解法吗？
 *
 * 递归回溯：本质上是一种枚举法
 *
 * 思路分析：
 * 1) 第一个皇后先放第一行第一列
 * 2) 第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都
 * 放完，找到一个合适
 * 3) 继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确
 * 解
 * 4) 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，
 * 全部得到.
 * 5) 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤
 *
 *
 * 小结：当我们选择了第一个皇后的位置之后，与其处于同行同列同斜线的位置便都无法被选择，第二个皇后只能放在未被第一个皇后所辐射到的位置上，接着放置第三个皇后，同样不能放在被前两个皇后辐射到的位置上，
 * 若此时已经没有未被辐射的位置能够被选择，也就意味着这种摆法是不可行的，我们需要回退到上一步，给第二个皇后重新选择一个未被第一个皇后辐射的位置，再来看是否有第三个皇后可以摆放的位置，如还是没有则再次回退至选择第二个皇后的位置，
 * 若第二个皇后也没有更多的选择则回退到第一个皇后，重新进行位置的选择。
 *
 * 完成一次可行解开始从递归的栈顶回溯，当递归找到出口后，此时递归栈的栈顶会被弹出，次栈顶元素会被顶上，即下一行会继续搜索每列的位置，直到搜索到第一行所有列为止
 *
 * 代码层面思路：
 *   1从第0行开始进行遍历（如果循环到了最后一行，接该种解决方法输出），
 *   2定义一个临时棋盘，用来遍历改行中每一列的所有子情况，
 *
 *   3每次循环子情况的时候需要初始化棋盘，就是将当前行放置的皇后清空，然后将棋盘 [当前行] [列]置为1
 *
 * 　4 然后检查循环的当前列是否能放置皇后如果不能放置皇后，就进行下一列的循环，如果能放置皇后，就调用在当前行的放置皇后的函数（需要传递的参数  就是将当前棋盘的情况【也就是创建的临时棋盘】
 *    【当前行数+1】），递归调用函数，遍历子情况
 *
    5　检查函数：思路就是判断当前放置皇后的 中上 左上 右上符不符合规就可以，不用判断下面的。因为子程序也会调用该检查函数，自然不会存在下面出现不符合规则的情况
 *
 *
 * 说明：
 * 若使用  int Q[8][8];  存储八皇后的数据，看起来比较直观，但是深入思考一下，每一行只存放1个数据，这样会造成空间的浪费，所以可使用  int Q[10];
 * 来存储八个皇后的位置，比如    Q[0]：第0行皇后的列数    Q[1]：第1行皇后的列数 ....
 *
 * 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] =
 * {0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1
 * 行的第 val+1 列
 *
 *
 * 与常规回溯法效率高的原因：常规回溯法回遍历每行的所有列的位置，即当前分支所有子节点位置都检测是否合法，而递归回溯则当前分支所有子节点都检测 ，皆不合法，直接退出递归
 *                     所以从算法时间复杂度来讲，回溯法基本计算单位多于递归回溯法
 *
 *
 * 递归回溯法基本框架：
 *
 * int a[n];
 *
 *  Queens(int k){
 *      if(k==n){//最后行皇后摆放ok
 *          return
 *      }
 *      for (int i = 下界; i <=上界; i++) {//从当前行第一列开始遍历当前行所有列可能出现的位置
 *        a[k]=i;//放一个皇后
 *        if(check(k)){//满足的约束条件，符和则放下一行位置的皇后
 *            Queens(k+1);
 *        }
 *        //如果此位置皇后位置不合法，则回溯到当前行的下一列的位置(i++)继续递归搜索
 *      }
 *  }
 *
 *
 *
 */
public class EightQueen {

    private  static   final  int maxCount=8;

    private  int  tailNumber=0;

    int[] queueArray=new  int[maxCount];


    public static void main(String[] args) {

        long start= System.currentTimeMillis();
        EightQueen eightQueens = new EightQueen();
        eightQueens. putQueens(0);
        long end= System.currentTimeMillis();
        System.out.println("一共存在的解："+ eightQueens.tailNumber);
        System.out.println("一共耗时"+(end-start));

    }

    //校验皇后放的位置合法性
    private  boolean isLegal(int n){
        for (int i = 0; i < n; i++) {
             //当前行的元素与前一行(n-1)的元素位于相同的列或者位于斜线上
              //行号-列号之差绝对值相等说明在同一条对角线上
             if (queueArray[n]==queueArray[i]||Math.abs(queueArray[n] - queueArray[i]) ==Math.abs(n-i)) {
                   return  false;
             }
        }
        return true;
    }

    //递归回溯放皇后
    private  void  putQueens(int n) {

        //这里产生了回溯，当递归找到出口后，此时递归栈的栈顶会被弹出，次栈顶元素会被顶上，即下一行会继续搜索每列的位置，直到搜索到第一行所有列为止
        if (n==maxCount) {//递归边界. 只要走到这里,所有皇后必然不冲突,找到一次可行解
            printQueens();
            return;
        }

        //遍历当前行的每一列
        for (int i = 1; i <=maxCount; i++) {
            queueArray[n]=i;//先把当前这个皇后 n , 放到该行的第 1 列
            if (isLegal(n)){//如果该位置皇后合法则递归放下一行的皇后
                putQueens(n+1);
            }
            //如果此位置皇后位置不合法，则回溯到当前行的下一列的位置(i++)
        }
    }

    private  void  printQueens(){
        tailNumber++;
        System.out.println("第"+tailNumber+"种解-----------------------------");
        for (int k : queueArray) {
            for (int j = 1; j <= maxCount; j++) {
                if (j == k) {
                    System.out.print(" * ");
                } else System.out.print(" 0 ");
            }
            System.out.println("");
        }
    }
}
