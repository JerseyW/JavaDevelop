package DataStructure.Graph;

/**
 * @author: Jerssy
 * @create: 2021-05-30 9:13
 * @version: V1.0
 * @slogan: 业精于勤, 荒于嬉;行成于思,毁于随。
 * @description: 位图
 *
 * 我们有1千万个整数，整数的范围在1到1亿之间。如何快速查找某个整数是否在这1千万个整数中呢？
 * 当然，这个问题还是可以用散列表来解决。不过，我们可以使用一种比较 “ 特殊 ” 的散列表，那就是位图。我们申请一个大小为 1 亿、数据类型为布尔类型（ true 或
 * 者 false ）的数组。我们将这 1 千万个整数作为数组下标，将对应的数组值设置成 true 。比如，整数 5 对应下标为 5 的数组值设置为 true ，也就是 array[5]=true 。
 * 当我们查询某个整数 K 是否在这 1 千万个整数中的时候，我们只需要将对应的数组值 array[K] 取出来，看是否等于 true 。如果等于 true ，那说明 1 千万整数中包含这个
 * 整数 K ；相反，就表示不包含这个整数 K 。
 * 不过，很多语言中提供的布尔类型，大小是 1 个字节的，并不能节省太多内存空间。实际上，表示 true 和 false 两个值，我们只需要用一个二进制位（ bit ）就可以
 * 了。那如何通过编程语言，来表示一个二进制位呢？
 * 这里就要用到位运算了。我们可以借助编程语言中提供的数据类型，比如 int 、 long 、 char 等类型，通过位运算，用其中的某个位表示某个数字。
 *
 * 位图通过数组下标来定位数据，所以，访问效率非常高。而且，每个数字用一个二进制位来表示，在数字范围不大
 * 的情况下，所需要的内存空间非常节省。
 *
 *
 * 布隆过滤器：我们仍然使用一个 1 亿个二进制大小的位图，然后通过哈希函数，对数字进
 * 行处理，让它落在这 1 到 1 亿范围内。比如我们把哈希函数设计成 f(x)=x%n 。其中， x 表示数字， n 表示位图的大小（ 1 亿），也就是，对数字跟位图的大小进行取模求余
 *
 * 布隆过滤器解决冲突： 使用K个哈希函数同时处理一个数字，得到的哈希值作为位图的索引下标，并设置为true,即用K个二进制位来表示一个数的存在
 *                    查询时用K个哈希函数同时求哈希值，如果哈希值在位图中都为true则表示该树存在，如果有一个不为true则表示不存在。
 *
 * 特点：1 内存占用少 2 有一定的判错率 判定存在的数据，有可能并不存在，但是对于判定不存在的数据，那肯定就不存在
 *
 * 布隆过滤器的误判率，主要跟哈希函数的个数、位图的大小有关。当我们往布隆过滤器中不停地加入数据之后，位图中不是 true 的位置就越来越少
 * 了，误判率就越来越高了。所以，对于无法事先知道要判重的数据个数的情况，我们需要支持自动扩容的功能
 *
 *
 * 布隆过滤器非常适合这种不需要 100% 准确的、允许存在小概率误判的大规模判重场景。
 * 除了爬虫网页去重这个例子，还有比如统计一个大型网站的每天的 UV 数，也就是每天有多少用户访问了网站，我们就可以使用布隆过滤器，对重复访问的用户，进行去重
 */
public class BitGraph {

    private final char[] bytes;
    private final int nbits;
    public BitGraph(int nbits) {
        this.nbits = nbits;
        this.bytes = new char[nbits/8+1];
    }
    public void set(int k) {
        if (k > nbits) return;
        int byteIndex = k / 8;
        int bitIndex = k % 8;
        bytes[byteIndex] |= (1 << bitIndex);
    }
    public boolean get(int k) {
        if (k > nbits) return false;
        int byteIndex = k / 8;
        int bitIndex = k % 8;
        return (bytes[byteIndex] & (1 << bitIndex)) != 0;
    }


}
